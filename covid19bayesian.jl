### A Pluto.jl notebook ###
# v0.9.4

using Markdown
macro bind(def, element)
    quote
        local el = $(esc(element))
        global $(esc(def)) = Core.applicable(Base.peek, el) ? Base.peek(el) : missing
        el
    end
end

# ‚ïî‚ïê‚ï° 0a97c596-a906-11ea-3a91-6d78a98e92b4
using Turing, Plots, Random, UrlDownload, DataFrames, Query, StatsPlots, Dates

# ‚ïî‚ïê‚ï° 68dcf87a-a934-11ea-2bd9-c95b9b4953ee
md"""
# COVID-19 Data Tutorial III
## Estimating R‚Çú: a simplified analysis
"""

# ‚ïî‚ïê‚ï° ed8a116e-a9cc-11ea-1c99-557d90d755f0
md"""
In this Pluto notebook, we'll build a model for estimating R‚Çú for COVID-19.

**Tooling**  

First, a note on the choice of format. [Pluto](https://github.com/fonsp/Pluto.jl) notebooks are a lightweight, Julia-specific alternative to Jupyter notebooks. The main advantage over Jupyter notebooks is that the dependency relationships between cells are managed internally by Pluto by analyzing your code, and changes automatically trigger re-calculation of dependent cells. This allows us to order the cells more flexibly and focus on the narrative, visualizations, etc.

Second, we're working in [Julia](https://discourse.julialang.org) here instead of Python because it allows us to substantially simplify our code, using the package [Turing](https://turing.ml/dev/). Don't worry if you aren't familiar with Julia; the syntax we use is going to be similar to what you've seen in other languages, and almost all of the ideas will map in a straightforward way to other environments.

Unlike the previous two tutorials, which were aimed at equipping you with common tools (Python, Pandas, and Colab), here we'll look to explore some things that are cool about alternative systems (Julia, Turing, and Pluto).
"""

# ‚ïî‚ïê‚ï° fa6f9a0e-a9cf-11ea-32d8-7b9667c709a5
md"""
## What is R‚Çú?
"""

# ‚ïî‚ïê‚ï° 03d9f846-a9d0-11ea-2a8c-db1c5bcc7eb1
md"""
Let's take a look at the relationship between R‚Çú, the average number of infection transmissions induced by each infectious person at time t, and the daily reported case totals.

Suppose that the R‚Çú curve looks like the top graph below. It starts around 2, decreasing over time to about 0.75. The daily case count flattens out around the time R‚Çú gets to about 1, and then it begins to decrease as R‚Çú gets smaller than 1.
"""

# ‚ïî‚ïê‚ï° 6c3b2f32-a9dc-11ea-3318-bf5c103a8728
md"### A probabilistic model"

# ‚ïî‚ïê‚ï° 8851d9fc-a9d7-11ea-2ec5-77d5e1799fbd
md"""
Let's think about how we would probablistically simulate the bottom figure given the top figure. We'll make several simplifying assumptions: 

1. Every infectious person is reported at the time they become infectious. This is an oversimplification and should be addressed to obtain a more complete model.
2. Each person is infectious for a specific number of days, which we'll call Œ≥‚Åª¬π.

Each day, the number of new reported cases is obtained as a sum of the cases generated by each infectious person over the previous Œ≥‚Åª¬π days. An infectious person infects Œ≥R‚Çú persons on average each day, so we can obtain the mean of the number of new cases by multiplying Œ≥R‚Çú for each of the previous Œ≥‚Åª¬π days by the corresponding day's number of new infections, and totaling the results.

The mean of this random variable approximately specifies its distribution, because it's approximately binomially distributed with large $n$ and small $p$. In other words, the random variable is approximately Poisson. 

Let's write this up in code. If `cases` is the vector of case counts, we have:

```julia
for i in 2:n
    cases[i] ~ Poisson(max(0, R‚Çú[i] / Œ≥‚Åª¬π * sum(cases[max(1, i-Œ≥‚Åª¬π):i-1])))
end
```
"""

# ‚ïî‚ïê‚ï° 33b1a3d4-a9da-11ea-2042-3bc91380623d
md"""
Remarkably, we can make a few more decisions about the distribution of `R‚Çú` and `cases` and we have a full-fledged Turing model:
"""

# ‚ïî‚ïê‚ï° a20a2338-a906-11ea-3510-57c76dfec1b1
@model SIR(n, R‚Çú, cases) = begin
	@assert ismissing(cases) || n == length(cases)
	Œ≥‚Åª¬π = 5
	if ismissing(R‚Çú)
		R‚Çú = zeros(Real, n)
	end
	R‚Çú[1] ~ Uniform(0.5, 3)
	for i in 2:n
		R‚Çú[i] ~ truncated(Normal(R‚Çú[i-1], 0.1), 0, Inf)
	end
	if ismissing(cases)
		cases = zeros(Integer, n)
	end
	cases[1] ~ DiscreteUniform(10, 100)
	for i in 2:n
		cases[i] ~ Poisson(max(0, R‚Çú[i] / Œ≥‚Åª¬π * sum(cases[max(1, i-Œ≥‚Åª¬π):i-1])))
	end
	R‚Çú, cases
end;

# ‚ïî‚ïê‚ï° 920e1f70-a9da-11ea-1791-1f218983b470
md"""
We can draw a sample from this model by supplying `missing` for the second and third arguments:
"""

# ‚ïî‚ïê‚ï° 85ca1838-a9f1-11ea-1540-65bf7e27156a
md"""
The plot we looked at previously shows the values of these series. 
"""

# ‚ïî‚ïê‚ï° ec25a016-a9da-11ea-0517-1561e07b8f53
md"""
## Bayesian inference

Now suppose we have the case values and want to infer the values of R‚Çú. The first thing to observe is that the R‚Çú values are not determined uniquely because of the randomness in the generation of the Poisson random variables. So the conditional distribution of R‚Çú given `cases` is the best we can hope for.

Remarkably, we can solve this apparently very complex inverse problem by just handing it to Turing (!!). We supply the observed values and call Turing's `sample` function. We also supply a sampler, in this case NUTS (*No U-Turn Sampler*). Turing provides a handful of samplers, and you can read about them [here](https://turing.ml/dev/docs/library/).
"""

# ‚ïî‚ïê‚ï° 85490956-a9dc-11ea-25ab-d19cbaa2cbaa
md"""
The way a sampler represents the distribution of the unobserved data given the observed data is by drawing many observations from that distribution (this is the last argument supplied to `sample` above). 

While this seems inferior to having a more direct description of the conditional distribution (a density, for example), in some ways it's better. 

For example, we can get a pretty good sense of the conditional distribution of R‚Çú by plotting the 500 runs obtained in the sampling process above:
"""

# ‚ïî‚ïê‚ï° e3630b54-a9dc-11ea-04d0-5dfc4628b5b7
md"""
We can use these observations to come up with error bars by computing the quantiles of the runs at each time. For example, if we plot the 10% and 90% quantiles we get:
"""

# ‚ïî‚ïê‚ï° 20c66d10-a9dd-11ea-108a-931d073bc563
md"""
It's hard to overstate how remarkable this is. We faced a difficult inverse problem and tackled it pretty effectively without having to do *any problem-specific thinking*. We just implemented the model, provided the observed data, and left it entirely up to the sampler to represent the conditional distribution of R‚Çú given the daily case counts.

Let's proceed to apply this to some real data!
"""

# ‚ïî‚ïê‚ï° 9eaf2a50-a90b-11ea-04fd-33ef1346a307
md"## Exploring the data"

# ‚ïî‚ïê‚ï° 9d46c4e8-a933-11ea-1978-3b20a8234ac4
md""" 
We're going to pull in our data sets from the COVID-19 Tracking Project. If you'd like to see the code for processing this data, check out the final section in this notebook (called "Bookkeeping").

Enter a comma-separated list of state abbreviations in the field below.
"""

# ‚ïî‚ïê‚ï° 96517798-a909-11ea-1a42-0713e5fa1f11
@bind state_string html"States: <input type='text' value='AK, AL'>"

# ‚ïî‚ïê‚ï° 414ed050-a90a-11ea-0ef1-e5a9ba28bc6e
md"""
## Bayesian Analysis

Now we'll apply the analysis we developed above to the data for a particular state.
"""

# ‚ïî‚ïê‚ï° 21414ce4-a936-11ea-0388-d31bb31a1041
@bind state html"State abbreviation: <input type='text' value='MS'>"

# ‚ïî‚ïê‚ï° 34d6108e-a9f2-11ea-0277-4b293391f4c1
md"""
## Conclusion

The analysis we've presented here includes some simplifying assumptions that we'd want to address as a next step. In addition to the ones mentioned above, you can see in the data that the reports of new cases are being batched by some states (check out South Carolina, for instance). 
"""

# ‚ïî‚ïê‚ï° 66f574b2-a9b7-11ea-1321-8f218f8f6d52
md"""
## üìí Bookkeeping
This section is for keeping track of code which is important for the calculations being performed in the notebook but secondary to the storyline. 
"""

# ‚ïî‚ïê‚ï° d4ed9996-a9d6-11ea-2cf4-f1e42e49ccc1
md"üëÅÔ∏è Package imports:"

# ‚ïî‚ïê‚ï° 23e02358-a9a9-11ea-3340-558722c47cff
begin
	default(fontfamily = "Palatino")
	md"üëÅÔ∏è Setting plot defaults"
end

# ‚ïî‚ïê‚ï° 50214920-a9d0-11ea-3534-c3865eb87fd4
begin
	seed = 37
	md"""
	üëÅÔ∏è Setting the seed for the random number generator so that we get reproducible 		results:
	"""
end

# ‚ïî‚ïê‚ï° e55e1006-a906-11ea-1b60-cf5e5dd4f8cb
begin
	Random.seed!(seed)
	R‚Çú, cases = SIR(50, missing, missing)()
end;

# ‚ïî‚ïê‚ï° dc2d3340-a906-11ea-33db-9300a16c9158
begin
	function plot_Rt_and_cases(R‚Çú, cases)
		plot(plot(R‚Çú, ylabel = "\$R_t\$", ylims = (0, 2.5), color = :green), 
	         sticks(max.(1, cases), ylabel = "daily new cases", xlabel="\$t\$"), 
		     layout = (2, 1), legend = false, fontfamily = "Palatino")
	end
	plot_Rt_and_cases(R‚Çú, cases)
end

# ‚ïî‚ïê‚ï° 069e6738-a937-11ea-2497-01aeb0808b7a
chn = sample(SIR(length(cases), missing, cases), NUTS(), 500);

# ‚ïî‚ïê‚ï° 7200a9d6-a990-11ea-09af-439c038ea0cd
plot(Array(chn[:R‚Çú])', leg = false, ylims = (0, 3))

# ‚ïî‚ïê‚ï° 237d736c-a99e-11ea-0195-318bdeff3049
begin
	function plot_chain(chn; times = missing, R‚Çú = missing)
		plot()
		runs = mean(Array(chn[:R‚Çú])', dims = 2)[:]
		if ismissing(times)
			times = 1:length(runs)
		end
		plot!(times, runs, ylims = (0, 3), label = "Estimated Rt")
		scatter!(times, runs, primary = false, ms = 3)
		if !ismissing(R‚Çú)
			plot!(times, R‚Çú, label = "Actual Rt", ylabel = "\$R_t\$", xlabel = "\$t\$")
			scatter!(times, R‚Çú, primary = false, ms = 3)	
		end
		q(chn, r) = [quantile(col, r) for col in eachcol(Array(chn[:R‚Çú]))]
		plot!(times, q(chn, 0.1), color = 1, fillrange = q(chn, 0.9),
			  fillalpha = 0.2, linewidth = 0, label = false)
		plot!(times, q(chn, 0.5), primary = false, ylims = (0, 3))
	end
	plot_chain(chn, R‚Çú = R‚Çú)
end

# ‚ïî‚ïê‚ï° d8616a8e-a90a-11ea-1a86-5141537c22d8
begin
	url = "https://covidtracking.com/api/v1/states/daily.csv"
	dateparse(s::String) = Date(parse(Int64, s[1:4]), parse(Int64, s[5:6]), parse(Int64, s[7:8]))
	dateparse(n::Int) = dateparse(string(n))
	df = DataFrame(urldownload(url));
	df[!, :date] = dateparse.(df[!, :date]);
	md"üëÅÔ∏è Downloading and processing the CSV file of daily state-by-state data"
end

# ‚ïî‚ïê‚ï° 34a82884-a909-11ea-19b9-6787df6630bd
begin
	states = split(replace(state_string, " " => ""), ",")
	subset_df = df |> 
				  @filter(_.state ‚àà states) |>
				  @orderby(_.state) |>
				  @thenby(_.date) |>
		 		  DataFrame
	md"üëÅÔ∏è Subsetting the daily case data based on the state values in the text field"
end

# ‚ïî‚ïê‚ï° 4804b622-a909-11ea-25d1-557ea0c43900
@df subset_df plot(:date, :positiveIncrease, 
				   group = :state, 
				   leg = :topleft,
				   title = "Daily coronavirus cases",
                   fontfamily = "Palatino")

# ‚ïî‚ïê‚ï° feca4e9a-a935-11ea-0dfd-7b399b1c8491
begin
	lookback = 5
	daily_cases = df |> 
		@filter(_.state == state && _.positive ‚â• 50) |> 
		@orderby(_.date) |> 
		DataFrame
	daily_cases_smoothed = [round(Integer, mean(daily_cases[:positiveIncrease][max(1,k-lookback):k])) for k in lookback+1:size(daily_cases,1)]
	md"üëÅÔ∏è Smooth the daily case count for a specific state"
end

# ‚ïî‚ïê‚ï° ccb18292-a936-11ea-29b2-4b0bb0bf03fc
plot(daily_cases[:date][lookback+1:end], daily_cases_smoothed, label = state, leg = :topleft, 
	 title = "Daily New Cases", fontfamily = "Palatino")

# ‚ïî‚ïê‚ï° 58bd5c02-a9df-11ea-0b9e-611a0f734928
state_chain = sample(SIR(length(daily_cases_smoothed), missing, daily_cases_smoothed), NUTS(), 500);

# ‚ïî‚ïê‚ï° 733dd19a-a9de-11ea-2ea8-5f0141be9e65
begin
	T = size(Array(state_chain[:R‚Çú]),2)
	plot_chain(state_chain, times = subset_df[end-T+1:end, :date], R‚Çú = missing)
end

# ‚ïî‚ïê‚ï° Cell order:
# ‚ïü‚îÄ68dcf87a-a934-11ea-2bd9-c95b9b4953ee
# ‚ïü‚îÄed8a116e-a9cc-11ea-1c99-557d90d755f0
# ‚ïü‚îÄfa6f9a0e-a9cf-11ea-32d8-7b9667c709a5
# ‚ïü‚îÄ03d9f846-a9d0-11ea-2a8c-db1c5bcc7eb1
# ‚ïü‚îÄdc2d3340-a906-11ea-33db-9300a16c9158
# ‚ïü‚îÄ6c3b2f32-a9dc-11ea-3318-bf5c103a8728
# ‚ïü‚îÄ8851d9fc-a9d7-11ea-2ec5-77d5e1799fbd
# ‚ïü‚îÄ33b1a3d4-a9da-11ea-2042-3bc91380623d
# ‚ï†‚ïêa20a2338-a906-11ea-3510-57c76dfec1b1
# ‚ïü‚îÄ920e1f70-a9da-11ea-1791-1f218983b470
# ‚ï†‚ïêe55e1006-a906-11ea-1b60-cf5e5dd4f8cb
# ‚ïü‚îÄ85ca1838-a9f1-11ea-1540-65bf7e27156a
# ‚ïü‚îÄec25a016-a9da-11ea-0517-1561e07b8f53
# ‚ï†‚ïê069e6738-a937-11ea-2497-01aeb0808b7a
# ‚ïü‚îÄ85490956-a9dc-11ea-25ab-d19cbaa2cbaa
# ‚ïü‚îÄ7200a9d6-a990-11ea-09af-439c038ea0cd
# ‚ïü‚îÄe3630b54-a9dc-11ea-04d0-5dfc4628b5b7
# ‚ïü‚îÄ237d736c-a99e-11ea-0195-318bdeff3049
# ‚ïü‚îÄ20c66d10-a9dd-11ea-108a-931d073bc563
# ‚ïü‚îÄ9eaf2a50-a90b-11ea-04fd-33ef1346a307
# ‚ïü‚îÄ9d46c4e8-a933-11ea-1978-3b20a8234ac4
# ‚ïü‚îÄ96517798-a909-11ea-1a42-0713e5fa1f11
# ‚ïü‚îÄ4804b622-a909-11ea-25d1-557ea0c43900
# ‚ïü‚îÄ414ed050-a90a-11ea-0ef1-e5a9ba28bc6e
# ‚ïü‚îÄ21414ce4-a936-11ea-0388-d31bb31a1041
# ‚ïü‚îÄccb18292-a936-11ea-29b2-4b0bb0bf03fc
# ‚ï†‚ïê58bd5c02-a9df-11ea-0b9e-611a0f734928
# ‚ïü‚îÄ733dd19a-a9de-11ea-2ea8-5f0141be9e65
# ‚ïü‚îÄ34d6108e-a9f2-11ea-0277-4b293391f4c1
# ‚ïü‚îÄ66f574b2-a9b7-11ea-1321-8f218f8f6d52
# ‚ïü‚îÄd4ed9996-a9d6-11ea-2cf4-f1e42e49ccc1
# ‚ï†‚ïê0a97c596-a906-11ea-3a91-6d78a98e92b4
# ‚ïü‚îÄ23e02358-a9a9-11ea-3340-558722c47cff
# ‚ïü‚îÄ50214920-a9d0-11ea-3534-c3865eb87fd4
# ‚ïü‚îÄd8616a8e-a90a-11ea-1a86-5141537c22d8
# ‚ïü‚îÄ34a82884-a909-11ea-19b9-6787df6630bd
# ‚ïü‚îÄfeca4e9a-a935-11ea-0dfd-7b399b1c8491
